#include "Hungarian.hpp"

API_BEGIN_NAMESPACE(Ai)

HungarianAlgorithm::HungarianAlgorithm()
{

}

HungarianAlgorithm::~HungarianAlgorithm()
{

}

double HungarianAlgorithm::Solve(std::vector<std::vector<double>> &DistMatrix, std::vector<int> &Assignment)
{
    if (DistMatrix.empty()) {
        return 0.0;
    }

    unsigned int nRows = DistMatrix.size();
    unsigned int nCols = DistMatrix[0].size();

    double cost = 0.0;
    int *assignment = new int[nRows];
    double *distMatrixIn = new double[nRows * nCols];

    for (unsigned int i = 0; i < nRows; i++) {
        for (unsigned int j = 0; j < nCols; j++) {
            distMatrixIn[i + nRows * j] = DistMatrix[i][j];
        }
    }

    assignmentoptimal(assignment, &cost, distMatrixIn, nRows, nCols);

    Assignment.clear();
    for (unsigned int r = 0; r < nRows; r++) {
        Assignment.emplace_back(assignment[r]);
    }

    delete[] distMatrixIn;
    delete[] assignment;

    return cost;
}

void HungarianAlgorithm::assignmentoptimal(int *assignment, double *cost, double *distMatrixIn, int nOfRows, int nOfColumns)
{
    int nOfElements, minDim, row, col;
    bool *coveredColumns, *coveredRows, *starMatrix, *newStarMatrix, *primeMatrix;
    double *distMatrix, *distMatrixTemp, *distMatrixEnd, *columnEnd, value, minValue;

    *cost = 0;
    for (row = 0; row < nOfRows; row++) {
        assignment[row] = -1;
    }

    nOfElements = nOfRows * nOfColumns;
    distMatrix = (double *)malloc(nOfElements * sizeof(double));
    distMatrixEnd = distMatrix + nOfElements;

    for (row = 0; row < nOfElements; row++) {
        value = distMatrixIn[row];
        distMatrix[row] = value;
    }

    coveredColumns = (bool *)calloc(nOfColumns, sizeof(bool));
    coveredRows = (bool *)calloc(nOfRows, sizeof(bool));
    starMatrix = (bool *)calloc(nOfElements, sizeof(bool));
    primeMatrix = (bool *)calloc(nOfElements, sizeof(bool));
    newStarMatrix = (bool *)calloc(nOfElements, sizeof(bool));

    if (nOfRows <= nOfColumns) {
        minDim = nOfRows;
        for (row = 0; row < nOfRows; row++) {
            distMatrixTemp = distMatrix + row;
            minValue = *distMatrixTemp;
            distMatrixTemp += nOfRows;

            while (distMatrixTemp < distMatrixEnd) {
                value = *distMatrixTemp;
                if (value < minValue) {
                    minValue = value;
                }
                distMatrixTemp += nOfRows;
            }

            distMatrixTemp = distMatrix + row;
            while (distMatrixTemp < distMatrixEnd) {
                *distMatrixTemp -= minValue;
                distMatrixTemp += nOfRows;
            }
        }

        for (row = 0; row < nOfRows; row++) {
            for (col = 0; col < nOfColumns; col++) {
                if (fabs(distMatrix[row + nOfRows * col]) < DBL_EPSILON) {
                    if (!coveredColumns[col]) {
                        starMatrix[row + nOfRows * col] = true;
                        coveredColumns[col] = true;
                        break;
                    }
                }
            }
        }
    } else {
        minDim = nOfColumns;
        for (col = 0; col < nOfColumns; col++) {
            distMatrixTemp = distMatrix + nOfRows * col;
            columnEnd = distMatrixTemp + nOfRows;

            minValue = *distMatrixTemp++;
            while (distMatrixTemp < columnEnd) {
                value = *distMatrixTemp++;
                if (value < minValue) {
                    minValue = value;
                }
            }

            distMatrixTemp = distMatrix + nOfRows * col;
            while (distMatrixTemp < columnEnd) {
                *distMatrixTemp++ -= minValue;
            }
        }

        for (col = 0; col < nOfColumns; col++) {
            for (row = 0; row < nOfRows; row++) {
                if (fabs(distMatrix[row + nOfRows * col]) < DBL_EPSILON) {
                    if (!coveredRows[row]) {
                        starMatrix[row + nOfRows * col] = true;
                        coveredColumns[col] = true;
                        coveredRows[row] = true;
                        break;
                    }
                }
            }
        }

        for (row = 0; row < nOfRows; row++) {
            coveredRows[row] = false;
        }
    }

    step2b(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
    computeassignmentcost(assignment, cost, distMatrixIn, nOfRows);

    free(distMatrix);
    free(coveredColumns);
    free(coveredRows);
    free(starMatrix);
    free(primeMatrix);
    free(newStarMatrix);
}

void HungarianAlgorithm::buildassignmentvector(int *assignment, bool *starMatrix, int nOfRows, int nOfColumns)
{
    int row, col;

    for (row = 0; row < nOfRows; row++) {
        for (col = 0; col < nOfColumns; col++) {
            if (starMatrix[row + nOfRows * col]) {
#ifdef ONE_INDEXING
                assignment[row] = col + 1;
#else
                assignment[row] = col;
#endif
                break;
            }
        }
    }
}

void HungarianAlgorithm::computeassignmentcost(int *assignment, double *cost, double *distMatrix, int nOfRows)
{
    int row, col;

    for (row = 0; row < nOfRows; row++) {
        col = assignment[row];
        if (col >= 0) {
            *cost += distMatrix[row + nOfRows * col];
        }
    }
}

void HungarianAlgorithm::step2a(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim)
{
    int col;
    bool *starMatrixTemp, *columnEnd;

    for (col = 0; col < nOfColumns; col++) {
        starMatrixTemp = starMatrix + nOfRows * col;
        columnEnd = starMatrixTemp + nOfRows;
        while (starMatrixTemp < columnEnd){
            if (*starMatrixTemp++) {
                coveredColumns[col] = true;
                break;
            }
        }
    }

    step2b(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
}

void HungarianAlgorithm::step2b(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim)
{
    int col, nOfCoveredColumns;

    nOfCoveredColumns = 0;
    for (col = 0; col < nOfColumns; col++) {
        if (coveredColumns[col]) {
            nOfCoveredColumns++;
        }
    }

    if (nOfCoveredColumns == minDim) {
        buildassignmentvector(assignment, starMatrix, nOfRows, nOfColumns);
    } else {
        step3(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
    }
}

void HungarianAlgorithm::step3(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim)
{
    bool zerosFound;
    int row, col, starCol;

    zerosFound = true;
    while (zerosFound) {
        zerosFound = false;
        for (col = 0; col < nOfColumns; col++) {
            if (!coveredColumns[col]) {
                for (row = 0; row < nOfRows; row++) {
                    if ((!coveredRows[row]) && (fabs(distMatrix[row + nOfRows * col]) < DBL_EPSILON)) {
                        primeMatrix[row + nOfRows * col] = true;
                        for (starCol = 0; starCol < nOfColumns; starCol++) {
                            if (starMatrix[row + nOfRows * starCol]) {
                                break;
                            }
                        }

                        if (starCol == nOfColumns) {
                            step4(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim, row, col);
                            return;
                        } else {
                            coveredRows[row] = true;
                            coveredColumns[starCol] = false;
                            zerosFound = true;
                            break;
                        }
                    }
                }
            }
        }
    }

    step5(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
}

void HungarianAlgorithm::step4(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim, int row, int col)
{
    int nOfElements = nOfRows * nOfColumns;
    int n, starRow, starCol, primeRow, primeCol;

    for (n = 0; n < nOfElements; n++) {
        newStarMatrix[n] = starMatrix[n];
    }

    newStarMatrix[row + nOfRows * col] = true;

    starCol = col;
    for (starRow = 0; starRow < nOfRows; starRow++) {
        if (starMatrix[starRow + nOfRows * starCol]) {
            break;
        }
    }

    while (starRow < nOfRows) {
        newStarMatrix[starRow + nOfRows * starCol] = false;
        primeRow = starRow;
        for (primeCol = 0; primeCol < nOfColumns; primeCol++) {
            if (primeMatrix[primeRow + nOfRows * primeCol]) {
                break;
            }
        }

        newStarMatrix[primeRow + nOfRows * primeCol] = true;
        
        starCol = primeCol;
        for (starRow = 0; starRow < nOfRows; starRow++) {
            if (starMatrix[starRow + nOfRows * starCol]) {
                break;
            }
        }
    }

    for (n = 0; n < nOfElements; n++) {
        primeMatrix[n] = false;
        starMatrix[n] = newStarMatrix[n];
    }

    for (n = 0; n < nOfRows; n++) {
        coveredRows[n] = false;
    }

    step2a(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
}

void HungarianAlgorithm::step5(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim)
{
    int row, col;
    double h, value;

    h = DBL_MAX;
    for (row = 0; row < nOfRows; row++) {
        if (!coveredRows[row]) {
            for (col = 0; col < nOfColumns; col++) {
                if (!coveredColumns[col]) {
                    value = distMatrix[row + nOfRows * col];
                    if (value < h) {
                        h = value;
                    }
                }
            }
        }
    }

    for (row = 0; row < nOfRows; row++) {
        if (coveredRows[row]) {
            for (col = 0; col < nOfColumns; col++) {
                distMatrix[row + nOfRows * col] += h;
            }
        }
    }

    for (col = 0; col < nOfColumns; col++) {
        if (!coveredColumns[col]) {
            for (row = 0; row < nOfRows; row++) {
                distMatrix[row + nOfRows * col] -= h;
            }
        }
    }

    step3(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
}

API_END_NAMESPACE(Ai)
